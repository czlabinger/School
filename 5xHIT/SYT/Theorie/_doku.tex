\section{Distributed Computing}
\subsection{ACID and BASE}
\subsubsection{ACID}
Transactions are used to ensure data is consitent.
These transactions consist of multiple commands that are either all executed or are not executed at all.

\paragraph{Atomicity} \mbox{}\\
Atomicity means that either the entire transaction is executed or it is not executed at all.
This prevents some statements to be executed while others aren't, which could lead to errors.

\paragraph{Consistency} \mbox{}\\
Consistency means that before and after a transaction is executed all the rules or contraints are met.

\paragraph{Isolation} \mbox{}\\
This means that transactions should be seperated from another but still be executed at the same time and should give the same result if they were run one after the other.
There are different isolation levels. Each level isolates some part of or the entire database from other transactions with the drawback that transactions can't be concurrent.

\paragraph{Durability} \mbox{}\\
This means that the data is stored persistently.

\subsubsection{BASE}
BASE is an alternative to ACID.

\paragraph{Basically-Available} \mbox{}\\
Transactions are atomically safed in a queue and are executed sequentially.

\paragraph{Soft-State} \mbox{}\\
After a specific time that a transaction has been in the queue it will be timeouted.

\paragraph{Eventually Consistent} \mbox{}\\
After all transactions have been executed the database is consistent.

\subsection{CAP}
It is only possible to achieve two out of the three following goals.

\subsubsection{Consistency}
All locations have the same data.

\subsubsection{Availability}
The system is available.

\subsubsection{Partition Tolerance}
This describes the system to be able to function even if some parts of it are cut off network wise.

\subsection{DiffSync}
Differential Syncronisation is an algorithm designed to syncronize documents across multiple devices. There must be an diff and patch algorithm for the type of data that should synced.

\subsubsection{Introduction}
DiffSync enables collaboration in real time.
The syncronization algorithm in an application is hard to change.
DiffSync can be used in existing applications.

Suited for:
\begin{itemize}
    \item unreliable/slow networks
    \item identical code on server/client
    \item No history required
    \item Scalable
\end{itemize}

Use cases:
\begin{itemize}
\item Pair programming on different systems
\item Remote debugging 
\end{itemize}

No problem when collaborating with someone or yourself with autosave feature because all versions are kept in sync.

\subsection{Alternatives}

\subsubsection{Pessemistic}
Only edit by one user at a time
Whole file is locked for other users
Refined version would be to only lock subsections but created problems for small files
\begin{itemize}
    \item Has to be supported by the application
\end{itemize}
Not good for unreliable networks

\subsubsection{Edit-Based}
Capture *all* edits (Typing, cut, paste, formatting, ...) and mirror them across all devices
If an edit is lost it will create a fork -> two different files

\subsubsection{Three way merge}

Client sends changes to server -> server performs 3 way merge -> merge gets send to the clients
If someone changes something while someone else is changing something it will result in a conflict
Not scalable

\subsection{Dual shadow method}

Client text and server shadow must be identical every half syncronization or server text and client shadow

Checksums after patch must be identical otherwise entire body must be sent again

\subsection{Topology}

Multiple clients connected to a single server.
The number of clients can become an issue -> load balanced servers with shared DB
Or server to server communication (two or more servers are connected with eachother). Servers can be added without a problem but can only be disconnected if no client is connected.
Latency may become an issue -> Can lead to complicated collisions. 
Can be reduced by avoiding long server chains and by increasing the sync time between servers

\subsection{Diff/Patch}
Diff/Patch algorithms are crucial. Efficiency improvements in these algorithms boost system performance. Can be used for plaintext and many more. Diff updates server shadows with client changes. It needs to differentiate minimal edits from semantic intent ensuring meaningful updates. Compares identical texts efficiently. Identifies shared starting/ending strings to speed up comparisons. Detects if a change is an addition or removal bypassing complex calculations.


Patches apply accurately, even if texts aren’t exact matches, using the Bitap algorithm for efficient near-match location. Merging non-text content may use a "last user wins" approach to prevent incorrect combinations.
Handling Collisions: Systems can address patch errors either by frequent, silent synchronization or user intervention on failed patches, balancing usability with data accuracy.

\subsection{Adaptive timing}
Client update frequency is critical for system responsiveness. Infrequent updates lead to costly operations and edit conflicts, while overly frequent updates strain the network. The Guaranteed Delivery Method reduces resource use by batching diffs for transmission. An adaptive system adjusts update frequency based on user activity, keeping updates efficient and responsive by shortening intervals during high activity and lengthening them when activity is low.

\subsection{Future work}
The fuzzy patch operation uses a three-way merge comparing Server Text and two versions of the Server Shadow. It only supports single synchronization packets limiting performance in high-latency connections. Additionally edits from all users are blended making attribution and individual rollbacks difficult.

\subsection{JavaScript implementation}
\subsubsection{Which implementation of diff-patch algorithms are used? How is it copied?}
It uses json-fast-patch.

\subsubsection{Where are the documents and shadows?}
The shadow and the backup are saved in `container.shadow`' or `container.backup` and the document in mainText. 
It can be copied by using `jsonpatch.deepClone\(mainText\)`.

\subsubsection{How and why can we ajust the sync-cycle? What are the advantage/disadvantages?}
We can adjust them to either have lower network traffic if we lower the cycles or faster syncronization if we increase the cycles.

\subsubsection{Where/How is the edit stack implemented?}
It is implemented as an array that is saved in the container as `container.edits`.

\subsubsection{It is possible to deploy a peer to peer version?}
Yes since the code of the client and server are nearly identical.

\subsubsection{How is it possible to use the API in other JS projects?}

\subsubsection{Are the JSON documents interchangable with other kinds of documents?}
It is possible but it would require the change from the json-fast-patch package to another one.

\subsubsection{How are conflicts handled?}
It just gets discarded.

\subsection{Firebase}

\subsubsection{Cloning the Repository}
\begin{verbatim}
git clone https://github.com/firebase/friendlychat
\end{verbatim}

\subsubsection{Creating flake.nix for NixOS Specific Behavior}
\begin{verbatim}
# flake.nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
    systems.url = "github:nix-systems/default";
  };

  outputs =
    { systems, nixpkgs, ... }@inputs:
    let
      eachSystem = f: nixpkgs.lib.genAttrs (import systems) (system: f nixpkgs.legacyPackages.${system});
    in
    {
      devShells = eachSystem (pkgs: {
        default = pkgs.mkShell {
          buildInputs = [
            pkgs.nodejs
            pkgs.nodePackages.firebase-tools
          ];
        };
      });
    };
}
\end{verbatim}

This is required to use dynamically linked libraries on NixOS systems.

Execute in the directory of the flake:
\begin{verbatim}
nix develop
\end{verbatim}

\subsubsection{Start}

\subsubsection{Login to Account}
\begin{verbatim}
firebase login
\end{verbatim}

\subsubsection{Authorize Firebase CLI}
\begin{verbatim}
firebase use --add
\end{verbatim}

\subsubsection{Deploy App}
\begin{verbatim}
firebase deploy --except functions
\end{verbatim}

\subsection{Install Dependencies}
Run:
\begin{verbatim}
npm i
\end{verbatim}
to install all dependencies.

\subsection{Setup in the Web Interface}
In the Firebase web interface, the storage had to be created and the project set up.

\subsection{Implement Functions}

\subsubsection{Enable Functions in Cloud Console}
\begin{verbatim}
// Import the Firebase SDK for Google Cloud Functions.
const functions = require('firebase-functions');
// Import and initialize the Firebase Admin SDK.
const admin = require('firebase-admin');
admin.initializeApp();

// TODO(DEVELOPER): Write the blurImages Function here.

// TODO(DEVELOPER): Write the sendNotification Function here.
\end{verbatim}

\subsubsection{Welcome Message}
\begin{verbatim}
// Adds a message that welcomes new users into the chat.
exports.addWelcomeMessages = functions.auth.user().onCreate(async (user) => {
  functions.logger.log('A new user signed in for the first time.');
  const fullName = user.displayName || 'Anonymous';

  // Saves the new welcome message into the database
  // which then displays it in the FriendlyChat clients.
  await admin.firestore().collection('messages').add({
    name: 'Firebase Bot',
    profilePicUrl: '/images/firebase-logo.png', // Firebase logo
    text: `${fullName} signed in for the first time! Welcome!`,
    timestamp: admin.firestore.FieldValue.serverTimestamp(),
  });
  functions.logger.log('Welcome message written to database.');
});
\end{verbatim}

Deploy the newly created functions:
\begin{verbatim}
firebase deploy --only functions
\end{verbatim}

\subsubsection{Exception During Deployment}
This command throws an exception: 
\texttt{No targets in firebase.json match ‘--only functions’}

Attempted solutions:
\begin{itemize}
    \item \texttt{firebase deploy functions}: No error message, only a note about \texttt{firebase [command] --help}.
    \item \texttt{firebase deploy}: Does not throw an error, but the function does not appear in the web interface and is not executed.
    \item \texttt{firebase deploy functions --add}: \texttt{unknown option --add}.
\end{itemize}

\section{Embedded Systems}

\subsection{Pico Development Environment for NixOS}

Repository: https://github.com/czlabinger/NixPicoEnv/

Open in VSCode, install and start the DevPods extension. SSH into the created container.
The template is located in \texttt{src}, and everything outside of \texttt{src} can be ignored.
Modify \texttt{CMakeLists.txt} to import the desired projects.


Building: 

`sh src/build.sh`

\subsection{Setup pico SDK}
`git clone https://github.com/raspberrypi/pico-sdk.git?submodules=1`\mbox{}\\
`cd pico-sdk`\mbox{}\\
`echo 'export PICO\_SDK\_PATH=/pico-sdk' >> ~/.bashrc`\mbox{}\\

\subsection{Blink}

The blink delay in the `blink.h` file had to be set to 25 to achieve the targeted frequency.

While pressing the BOOTSEL button on the pi while plugging it in it can be mounted via:

`sudo dmesg | tail` this should show a new drive sdX. Now mount this drive using `sudo mount /dev/sdX /mnt`. Now the generated uf2 file can be copied onto the pi. Lastly execute `sudo sync` for the pi to acknowlege the changes.

\subsection{CAN}
\subsubsection{Operation-Modes MCP2515}
\begin{itemize}
  \item \textbf{Normal Mode:} Standard mode in which the controller can send and receive messages.
  \item \textbf{Sleep Mode:} Power-saving mode in which the controller consumes minimal current and does not process messages. An external wake-up can reactivate the controller.
  \item \textbf{Loopback Mode:} Internal test mode where sent messages are directly received without leaving the CAN bus. Ideal for tests without an external CAN network.
  \item \textbf{Listen-Only Mode (Default):} Receive-only mode where the controller reads received messages without sending ACK bits. Often used for bus diagnostics.
  \item \textbf{Configuration Mode:} Configuration mode where settings such as bitrate and filters of the controller can be configured.
\end{itemize}

\subsubsection{Pins}

\begin{tabular}{||c c||} 
  \hline
  MCP2515 & Pico \\ [0.5ex] 
  \hline
  
  \hline
  VCC1(5V) & VBUS \\ 
  \hline
  3,3V(OUT) & VCC(3,3V) \\
  \hline
  PIN\_MISO & GP4 \\
  \hline
  PIN\_CS\_A & GP5 \\
  \hline
  PIN\_SCK & GP6 \\
  \hline
  PIN\_MOSI & GP7 \\
  \hline
\end{tabular}

\subsubsection{Code}
After connecting the pins as described above the code from https://github.com/a-kipp/RP2040-CAN-Driver and changing the pins and setting the mode to normal mode it is now possible to connect two picos over a logic analyzer where one is connected to CANH and one to CANL.


\subsection{Hello USB}
Using `minicom -D /dev/ttyACM0 -b 115200` it is possible to read the output from printf calls on the another device that is connected via usb.
